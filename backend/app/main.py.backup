"""
FastAPI application setup for Harv v2.0 - PRODUCTION READY
Enhanced with complete endpoint integration, monitoring, and demo features
"""

from fastapi import FastAPI, HTTPException, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
import logging
import time
from datetime import datetime
import psutil
import os

from .core.config import settings
from .core.database import create_tables
from .api.v1.api import api_router  # Updated to include all production endpoints

# Configure comprehensive logging
logging.basicConfig(
    level=logging.INFO if settings.debug else logging.WARNING,
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# Create FastAPI application with enhanced configuration
app = FastAPI(
    title=settings.app_name,
    version=settings.version,
    description="""
    üß† **Harv v2.0 - Intelligent Tutoring System**
    
    **‚ú® Enhanced 4-Layer Memory Architecture**
    - Layer 1: User learning profile and cross-module mastery
    - Layer 2: Module-specific context and teaching configuration  
    - Layer 3: Real-time conversation state and message history
    - Layer 4: Cross-module prior knowledge connections
    
    **üéì Socratic Methodology Integration**
    - Discovery-based learning through strategic questioning
    - Personalized teaching approaches based on learning style
    - Cross-module knowledge building and retention
    
    **üöÄ Production-Ready Features**
    - JWT authentication and security
    - Comprehensive health monitoring
    - Real-time performance metrics (NO FAKE DATA)
    - Live database monitoring with actual SQL queries
    - Functional chat interface with memory integration
    - Complete learning modules with progress tracking
    - User onboarding and personalization system
    - Admin content management interface
    
    **üéØ Live Demo Features**
    - Real SQL monitoring and database queries
    - Actual memory system performance measurement
    - Dynamic API response tracking
    - Complete functional frontend integration
    - 5 communication theory modules fully configured
    """,
    docs_url="/docs" if settings.debug else None,
    redoc_url="/redoc" if settings.debug else None,
)

# Enhanced CORS middleware for production
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.cors_origins,
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "PATCH"],
    allow_headers=["*"],
    expose_headers=["X-Request-ID", "X-Processing-Time"],
)

# Request timing middleware for performance monitoring
@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
    """Add processing time to response headers for monitoring"""
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    
    # Log slow requests (> 1 second)
    if process_time > 1.0:
        logger.warning(f"Slow request: {request.method} {request.url.path} took {process_time:.2f}s")
    
    return response

# Startup event - database and system initialization
@app.on_event("startup")
async def startup_event():
    """Initialize database and perform startup tasks"""
    try:
        # Create database tables
        create_tables()
        
        # System startup logging
        logger.info(f"üöÄ {settings.app_name} v{settings.version} starting up...")
        logger.info(f"üìä Debug mode: {settings.debug}")
        logger.info(f"üóÑÔ∏è Database: {settings.database_url}")
        logger.info(f"üîë OpenAI configured: {'Yes' if settings.openai_api_key else 'No'}")
        logger.info(f"üåê CORS origins: {settings.cors_origins}")
        
        # Performance baseline
        system_info = {
            "cpu_count": psutil.cpu_count(),
            "memory_gb": round(psutil.virtual_memory().total / (1024**3), 1),
            "python_version": os.sys.version.split()[0],
            "startup_time": datetime.now().isoformat()
        }
        logger.info(f"üñ•Ô∏è System info: {system_info}")
        
        print(f"\n‚úÖ {settings.app_name} v{settings.version} READY!")
        print(f"üìö API Documentation: http://localhost:8000/docs")
        print(f"üß† Memory System: Enhanced 4-Layer Architecture")
        print(f"üéì Modules: 5 Communication Theory Modules")
        print(f"üìä Monitoring: Live metrics and SQL activity")
        print(f"üîê Auth: JWT with secure password hashing")
        
    except Exception as e:
        logger.error(f"‚ùå Startup failed: {e}")
        raise

# Shutdown event
@app.on_event("shutdown")
async def shutdown_event():
    """Cleanup tasks on shutdown"""
    logger.info("üõë Shutting down Harv v2.0...")

# Enhanced global exception handler
@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    """Handle unexpected errors gracefully with detailed logging"""
    
    # Log the error with request context
    error_id = int(time.time())
    logger.error(
        f"Global exception {error_id}: {type(exc).__name__}: {exc}\n"
        f"Request: {request.method} {request.url}\n"
        f"Headers: {dict(request.headers)}"
    )
    
    if settings.debug:
        # In debug mode, show the actual error
        return JSONResponse(
            status_code=500,
            content={
                "error": "Internal server error",
                "detail": str(exc),
                "type": type(exc).__name__,
                "error_id": error_id,
                "debug": True,
                "request_path": str(request.url.path)
            }
        )
    else:
        # In production, hide error details
        return JSONResponse(
            status_code=500,
            content={
                "error": "Internal server error",
                "message": "An unexpected error occurred",
                "error_id": error_id,
                "support": "Please contact support with this error ID"
            }
        )

# WebSocket endpoint for live metrics streaming
from fastapi import WebSocket, WebSocketDisconnect
import json
import asyncio

class ConnectionManager:
    def __init__(self):
        self.active_connections: list[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)

    async def broadcast_metrics(self, data: dict):
        for connection in self.active_connections:
            try:
                await connection.send_text(json.dumps(data))
            except:
                pass

manager = ConnectionManager()

@app.websocket("/api/v1/metrics/live-metrics")
async def websocket_live_metrics(websocket: WebSocket):
    """WebSocket endpoint for real-time metrics streaming"""
    await manager.connect(websocket)
    try:
        while True:
            # Get real system metrics
            cpu_percent = psutil.cpu_percent(interval=0.1)
            memory = psutil.virtual_memory()
            
            metrics_data = {
                "timestamp": datetime.now().isoformat(),
                "system": {
                    "cpu_usage": round(cpu_percent, 1),
                    "memory_usage": round(memory.percent, 1),
                    "memory_available_gb": round(memory.available / (1024**3), 2)
                },
                "api": {
                    "active_connections": len(manager.active_connections),
                    "uptime_seconds": round(time.time() - psutil.boot_time(), 0)
                }
            }
            
            await manager.broadcast_metrics(metrics_data)
            await asyncio.sleep(2)  # Update every 2 seconds
            
    except WebSocketDisconnect:
        manager.disconnect(websocket)

# Static file serving for demo.html
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
import os

# Serve demo.html at /demo route
@app.get("/demo")
async def serve_demo():
    """Serve the complete functional demo interface"""
    demo_path = os.path.join(os.path.dirname(__file__), "..", "..", "demo.html")
    if os.path.exists(demo_path):
        return FileResponse(demo_path)
    else:
        return JSONResponse(
            status_code=404,
            content={
                "error": "Demo interface not found", 
                "message": "demo.html should be in project root",
                "suggestion": "Copy demo.html to project root directory"
            }
        )

# Root endpoint with system overview
@app.get("/")
async def root():
    """Root endpoint - Complete system overview for stakeholders"""
    
    # Get current system metrics
    cpu_percent = psutil.cpu_percent(interval=0.1)
    memory = psutil.virtual_memory()
    disk = psutil.disk_usage('/')
    
    system_stats = {
        "cpu_usage_percent": round(cpu_percent, 1),
        "memory_usage_percent": round(memory.percent, 1),
        "memory_available_gb": round(memory.available / (1024**3), 2),
        "disk_usage_percent": round(disk.percent, 1),
        "uptime_seconds": round(time.time() - psutil.boot_time(), 0)
    }
    
    return {
        "message": f"Welcome to {settings.app_name} v{settings.version}",
        "status": "üöÄ PRODUCTION READY",
        "timestamp": datetime.now().isoformat(),
        "system_health": system_stats,
        
        # Core Intelligence Features
        "enhanced_memory_system": {
            "status": "‚úÖ ACTIVE",
            "description": "4-layer memory architecture with cross-module learning",
            "endpoint": "/api/v1/memory/enhanced/{module_id}",
            "layers": [
                "Layer 1: User learning profile & cross-module mastery", 
                "Layer 2: Module context & Socratic configuration",
                "Layer 3: Real-time conversation state & history",
                "Layer 4: Prior knowledge connections & insights"
            ]
        },
        
        "socratic_tutoring": {
            "status": "‚úÖ FUNCTIONAL", 
            "description": "Discovery-based learning through strategic questioning",
            "endpoint": "/api/v1/chat/enhanced",
            "methodology": "Prevents direct answers, encourages critical thinking"
        },
        
        # Production Ready Features
        "live_monitoring": {
            "status": "‚úÖ ACTIVE",
            "description": "Real performance metrics - NO FAKE DATA", 
            "endpoints": {
                "system_health": "/api/v1/health/detailed",
                "live_metrics": "/api/v1/demo/system-overview",
                "sql_activity": "/api/v1/demo/sql/stats",
                "memory_performance": "/api/v1/memory/enhanced/1?current_message=test"
            }
        },
        
        "learning_modules": {
            "status": "‚úÖ CONFIGURED",
            "count": 5,
            "endpoint": "/api/v1/modules/",
            "modules": [
                "Module 1: Your Four Worlds - Communication models & perception",
                "Module 2: Writing - The persistence of words evolution", 
                "Module 3: Books - Birth of mass communication",
                "Module 4: Mass Communication Theory - Media effects",
                "Module 5: Digital Revolution - Modern transformation"
            ]
        },
        
        "user_management": {
            "status": "‚úÖ SECURE",
            "features": [
                "JWT authentication with secure tokens",
                "Bcrypt password hashing", 
                "User registration and profile management",
                "Personalized onboarding system",
                "Learning style assessment and memory configuration"
            ],
            "endpoints": {
                "register": "/api/v1/auth/register",
                "login": "/api/v1/auth/login", 
                "profile": "/api/v1/users/me",
                "onboarding": "/api/v1/onboarding/start"
            }
        },
        
        "admin_features": {
            "status": "‚úÖ ACTIVE",
            "description": "Content management system for modules and configuration",
            "endpoint": "/api/v1/admin/modules/{module_id}/content",
            "features": [
                "Module content editing",
                "System prompt configuration", 
                "Learning objective management",
                "Content export/import",
                "Performance analytics dashboard"
            ]
        },
        
        # Technical Architecture
        "architecture": {
            "backend": "FastAPI with SQLAlchemy ORM",
            "database": "SQLite (dev) / PostgreSQL (prod)",
            "ai_integration": "OpenAI GPT with enhanced memory context",
            "frontend": "React with TypeScript",
            "authentication": "JWT with HttpOnly cookies",
            "deployment": "Docker containerization ready"
        },
        
        # API Documentation
        "documentation": {
            "openapi_docs": "/docs" if settings.debug else "Available in development mode",
            "redoc": "/redoc" if settings.debug else "Available in development mode", 
            "health_check": "/api/v1/health/",
            "api_version": "v1",
            "total_endpoints": "25+ production endpoints"
        },
        
        # Quick Demo Links
        "demo_links": {
            "system_overview": "/api/v1/demo/system-overview",
            "memory_demo": "/api/v1/memory/enhanced/1?current_message=What%20is%20communication?",
            "modules_list": "/api/v1/modules/",
            "health_detailed": "/api/v1/health/detailed",
            "sql_activity": "/api/v1/demo/sql/conversations"
        }
    }

# Additional health endpoint for monitoring
@app.get("/health")
async def simple_health():
    """Simple health check for load balancers"""
    return {"status": "healthy", "timestamp": datetime.now().isoformat()}

# Version endpoint
@app.get("/version")
async def version():
    """Get application version information"""
    return {
        "name": settings.app_name,
        "version": settings.version,
        "build": "production-ready",
        "features": [
            "Enhanced 4-layer memory system",
            "Socratic tutoring methodology", 
            "Real-time performance monitoring",
            "Complete learning module system",
            "User onboarding and personalization",
            "Admin content management"
        ]
    }
